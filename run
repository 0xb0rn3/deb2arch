#!/usr/bin/env bash
set -e

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
echo "‚ïë      deb2arch - .deb to Arch Converter        ‚ïë"
echo "‚ïë      Engineered by: oxbv1 | 0xb0rn3           ‚ïë"
echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
echo ""

# Function to install dependencies
install_dependencies() {
    local missing_deps=()
    local dep_packages=()
    
    # Check core dependencies
    command -v ar &> /dev/null || missing_deps+=("ar (binutils)")
    command -v bsdtar &> /dev/null || missing_deps+=("bsdtar (libarchive)")
    command -v makepkg &> /dev/null || missing_deps+=("makepkg (pacman)")
    command -v python3 &> /dev/null || missing_deps+=("python3")
    command -v readelf &> /dev/null || missing_deps+=("readelf (binutils)")
    command -v ldd &> /dev/null || missing_deps+=("ldd (glibc)")
    
    if [ ${#missing_deps[@]} -gt 0 ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Missing dependencies detected:${NC}"
        for dep in "${missing_deps[@]}"; do
            echo "   - $dep"
        done
        echo ""
        
        read -p "Install missing dependencies automatically? [Y/n]: " install_deps
        install_deps=${install_deps:-y}
        
        if [[ "$install_deps" =~ ^[Yy]$ ]]; then
            echo -e "${CYAN}üì¶ Installing dependencies...${NC}"
            
            # Map to actual package names
            local packages_to_install=()
            for dep in "${missing_deps[@]}"; do
                case "$dep" in
                    *binutils*) packages_to_install+=("binutils") ;;
                    *libarchive*) packages_to_install+=("libarchive") ;;
                    *pacman*) packages_to_install+=("pacman") ;;
                    *python3*) packages_to_install+=("python") ;;
                    *glibc*) packages_to_install+=("glibc") ;;
                esac
            done
            
            # Remove duplicates
            packages_to_install=($(echo "${packages_to_install[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))
            
            # Install with system package manager
            if sudo pacman -S --needed --noconfirm "${packages_to_install[@]}"; then
                echo -e "${GREEN}‚úÖ Dependencies installed successfully!${NC}"
                echo ""
            else
                echo -e "${RED}‚ùå Failed to install dependencies${NC}"
                exit 1
            fi
        else
            echo -e "${RED}Cannot continue without required dependencies${NC}"
            exit 1
        fi
    fi
}

# Check and install dependencies
install_dependencies

# Verify Python is now available
PYTHON_AVAILABLE=false
if command -v python3 &> /dev/null; then
    PYTHON_AVAILABLE=true
fi

# Debian to Arch package name translation map
declare -A DEB_TO_ARCH=(
    # Common library mappings
    ["libxcb-cursor0"]="xcb-util-cursor"
    ["libncursesw5"]="ncurses"
    ["libncursesw5-dev"]="ncurses"
    ["libsox-dev"]="sox"
    ["libxml2-dev"]="libxml2"
    ["libcdio-dev"]="libcdio"
    ["libcdio-cdda-dev"]="libcdio"
    ["libcdio-paranoia-dev"]="libcdio-paranoia"
    ["libmagic-dev"]="file"
    ["libfreetype6-dev"]="freetype2"
    ["libavahi-gobject-dev"]="avahi"
    ["libsm-dev"]="libsm"
    ["libxrender-dev"]="libxrender"
    ["libfontconfig1-dev"]="fontconfig"
    ["libxext-dev"]="libxext"
    ["libgtk-3-0"]="gtk3"
    ["libgtk-3-dev"]="gtk3"
    ["libnotify4"]="libnotify"
    ["libnss3"]="nss"
    ["libxtst6"]="libxtst"
    ["libatspi2.0-0"]="at-spi2-core"
    ["libdrm2"]="libdrm"
    ["libgbm1"]="mesa"
    ["libxcb-dri3-0"]="libxcb"
    ["libglib2.0-bin"]="glib2"
    ["libglib2.0-0"]="glib2"
    ["gvfs-bin"]="gvfs"
    ["pulseaudio"]="pulseaudio"
    ["libasound2"]="alsa-lib"
    ["libgmp3-dev"]="gmp"
    ["build-essential"]="base-devel"
    ["libssl-dev"]="openssl"
    ["libcurl4"]="curl"
    ["libcurl3"]="curl"
    ["libsqlite3-0"]="sqlite"
    ["libqt5core5a"]="qt5-base"
    ["libqt5gui5"]="qt5-base"
    ["libqt5widgets5"]="qt5-base"
    ["libqt6core6"]="qt6-base"
    ["libqt6gui6"]="qt6-base"
    ["libqt6widgets6"]="qt6-base"
    
    # Remove -dev suffix (Arch doesn't split dev packages)
    [".*-dev$"]="strip-dev"
)

# Function to create Python dependency analyzer
create_python_analyzer() {
    # Check if Python packages are needed
    local python_deps_needed=false
    
    # We only use stdlib, no external packages needed
    # But let's verify Python can run our script
    if ! python3 -c "import subprocess, sys, re; from pathlib import Path" 2>/dev/null; then
        echo -e "${RED}‚ùå Python standard library modules missing${NC}"
        echo "This is unusual - Python installation may be corrupted"
        exit 1
    fi
    
    cat > /tmp/deb2arch_analyzer.py << 'PYEOF'
#!/usr/bin/env python3
"""
deb2arch Dependency Analyzer
Uses only Python standard library - no external dependencies
"""
import subprocess
import sys
import re
from pathlib import Path

def analyze_elf_dependencies(file_path):
    """Extract library dependencies from ELF binaries using readelf"""
    deps = set()
    try:
        result = subprocess.run(
            ['readelf', '-d', file_path], 
            capture_output=True, 
            text=True, 
            timeout=5
        )
        if result.returncode == 0:
            for line in result.stdout.split('\n'):
                if 'NEEDED' in line:
                    match = re.search(r'\[(.*?)\]', line)
                    if match:
                        deps.add(match.group(1))
    except (subprocess.TimeoutExpired, FileNotFoundError, Exception):
        pass
    return deps

def map_library_to_package(lib):
    """Map library names to Arch package names"""
    # Comprehensive library to package mapping
    lib_map = {
        # Qt frameworks
        'libQt5': 'qt5-base',
        'libQt6': 'qt6-base',
        'libKF5': 'kf5',
        
        # GTK/GNOME
        'libgtk-3': 'gtk3',
        'libgtk-4': 'gtk4',
        'libglib-2': 'glib2',
        'libgio-2': 'glib2',
        'libgobject-2': 'glib2',
        'libgdk-3': 'gtk3',
        'libcairo': 'cairo',
        'libpango': 'pango',
        'libatk': 'atk',
        
        # Crypto/Security
        'libssl.so': 'openssl',
        'libcrypto.so': 'openssl',
        
        # Networking
        'libcurl.so': 'curl',
        'libcurl-gnutls.so': 'curl',
        
        # Database
        'libsqlite3.so': 'sqlite',
        'libpq.so': 'postgresql-libs',
        'libmysqlclient.so': 'mariadb-libs',
        
        # Media
        'libavcodec.so': 'ffmpeg',
        'libavformat.so': 'ffmpeg',
        'libavutil.so': 'ffmpeg',
        'libswscale.so': 'ffmpeg',
        'libSDL2': 'sdl2',
        'libpulse': 'libpulse',
        'libasound': 'alsa-lib',
        
        # Graphics
        'libGL.so': 'mesa',
        'libGLX.so': 'mesa',
        'libEGL.so': 'mesa',
        'libvulkan.so': 'vulkan-icd-loader',
        
        # X11
        'libX11.so': 'libx11',
        'libXext.so': 'libxext',
        'libXrender.so': 'libxrender',
        'libxcb.so': 'libxcb',
        
        # Python
        'libpython3': 'python',
        'libpython2': 'python2',
        
        # System libraries (usually skip these)
        'libc.so': None,  # glibc (base system)
        'libm.so': None,  # glibc
        'libpthread.so': None,  # glibc
        'libdl.so': None,  # glibc
        'libstdc++.so': None,  # gcc-libs (base system)
        'libgcc_s.so': None,  # gcc-libs
        'ld-linux': None,  # glibc
    }
    
    # Check exact matches first
    for pattern, pkg in lib_map.items():
        if pattern in lib:
            return pkg
    
    # Try to extract package name from library name
    # Pattern: libNAME.so.VERSION -> NAME
    match = re.match(r'lib(.+?)\.so', lib)
    if match:
        base_name = match.group(1)
        # Don't suggest system libraries
        if base_name not in ['c', 'm', 'pthread', 'dl', 'rt']:
            return base_name
    
    return None

def scan_extracted_package(extract_dir):
    """Scan extracted .deb for binary dependencies"""
    all_deps = set()
    extract_path = Path(extract_dir)
    
    # Find all ELF binaries
    for file_path in extract_path.rglob('*'):
        if not file_path.is_file():
            continue
            
        try:
            # Check if it's an ELF binary (magic bytes: 0x7f 'E' 'L' 'F')
            with open(file_path, 'rb') as f:
                magic = f.read(4)
                if magic == b'\x7fELF':
                    deps = analyze_elf_dependencies(str(file_path))
                    all_deps.update(deps)
        except (IOError, OSError, PermissionError):
            continue
    
    # Map libraries to packages
    packages = set()
    for lib in all_deps:
        pkg = map_library_to_package(lib)
        if pkg:  # None means skip (system library)
            packages.add(pkg)
    
    return sorted(packages)

def main():
    if len(sys.argv) != 2:
        print("Usage: deb2arch_analyzer.py <extract_directory>", file=sys.stderr)
        sys.exit(1)
    
    extract_dir = sys.argv[1]
    
    if not Path(extract_dir).exists():
        print(f"Error: Directory not found: {extract_dir}", file=sys.stderr)
        sys.exit(1)
    
    try:
        deps = scan_extracted_package(extract_dir)
        # Return comma-separated list
        print(','.join(deps))
    except Exception as e:
        print(f"Error analyzing package: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()
PYEOF
    chmod +x /tmp/deb2arch_analyzer.py
}

# Function to translate Debian package name to Arch equivalent
translate_package() {
    local deb_pkg=$1
    
    # Strip version constraints
    deb_pkg=$(echo "$deb_pkg" | sed 's/ *([^)]*)//g' | xargs)
    
    # Check direct mapping
    if [ -n "${DEB_TO_ARCH[$deb_pkg]}" ]; then
        echo "${DEB_TO_ARCH[$deb_pkg]}"
        return
    fi
    
    # Strip -dev suffix
    if [[ "$deb_pkg" =~ -dev$ ]]; then
        echo "${deb_pkg%-dev}"
        return
    fi
    
    # Strip lib prefix and version numbers for libraries
    if [[ "$deb_pkg" =~ ^lib.*[0-9]+$ ]]; then
        echo "$deb_pkg" | sed 's/[0-9]*$//'
        return
    fi
    
    # Return as-is if no translation found
    echo "$deb_pkg"
}

# Function to verify package exists in Arch repos
verify_arch_package() {
    local pkg=$1
    if pacman -Ss "^${pkg}$" &>/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# Function to extract package info from .deb
extract_deb_info() {
    local debfile=$1
    local tmpdir=$(mktemp -d)
    
    cd "$tmpdir"
    ar x "$debfile" 2>/dev/null || true
    
    if [ -f control.tar.gz ]; then
        tar xzf control.tar.gz ./control 2>/dev/null || true
    elif [ -f control.tar.xz ]; then
        tar xJf control.tar.xz ./control 2>/dev/null || true
    elif [ -f control.tar.zst ]; then
        tar --zstd -xf control.tar.zst ./control 2>/dev/null || true
    fi
    
    if [ -f control ]; then
        cat control
    fi
    
    cd - > /dev/null
    rm -rf "$tmpdir"
}

# Function to deeply analyze binary dependencies
deep_analyze_dependencies() {
    local deb_file=$1
    local tmpdir=$(mktemp -d)
    
    echo -e "${CYAN}üî¨ Performing deep dependency analysis...${NC}"
    
    cd "$tmpdir"
    ar x "$deb_file" 2>/dev/null || true
    
    # Extract data
    if [ -f data.tar.xz ]; then
        tar xJf data.tar.xz 2>/dev/null || true
    elif [ -f data.tar.gz ]; then
        tar xzf data.tar.gz 2>/dev/null || true
    elif [ -f data.tar.zst ]; then
        tar --zstd -xf data.tar.zst 2>/dev/null || true
    fi
    
    local detected_deps=""
    
    # Use Python analyzer if available (uses only stdlib, no pip packages)
    if [ "$PYTHON_AVAILABLE" = true ] && command -v readelf &> /dev/null; then
        create_python_analyzer
        detected_deps=$(python3 /tmp/deb2arch_analyzer.py "$tmpdir" 2>/dev/null || echo "")
        
        if [ -n "$detected_deps" ]; then
            echo -e "${GREEN}   ‚úì Binary analysis complete${NC}"
        fi
    else
        echo -e "${YELLOW}   ‚ö† Python/readelf not available, using fallback method${NC}"
    fi
    
    # Fallback: Use ldd if Python not available
    if [ -z "$detected_deps" ]; then
        local libs=$(find "$tmpdir" -type f -executable -exec ldd {} \; 2>/dev/null | \
                    grep "=>" | awk '{print $1}' | sort -u)
        
        local packages=""
        for lib in $libs; do
            case "$lib" in
                libQt5*) packages="$packages qt5-base";;
                libQt6*) packages="$packages qt6-base";;
                libgtk-3*) packages="$packages gtk3";;
                libssl*|libcrypto*) packages="$packages openssl";;
                libcurl*) packages="$packages curl";;
            esac
        done
        detected_deps=$(echo "$packages" | tr ' ' ',' | sed 's/,,*/,/g; s/^,//; s/,$//')
    fi
    
    cd - > /dev/null
    rm -rf "$tmpdir"
    
    echo "$detected_deps"
}

# Spinner function for build process
show_spinner() {
    local pid=$1
    local message=$2
    local spinstr='‚†ã‚†ô‚†π‚†∏‚†º‚†¥‚†¶‚†ß‚†á‚†è'
    local i=0
    
    tput civis # Hide cursor
    while kill -0 $pid 2>/dev/null; do
        i=$(( (i+1) %10 ))
        printf "\r${CYAN}${message} ${spinstr:$i:1}${NC}"
        sleep 0.1
    done
    tput cnorm # Show cursor
    printf "\r"
}

# Get package source
echo "üì¶ Package Source"
echo "1) Local .deb file"
echo "2) URL to .deb file"
read -p "Select option [1-2]: " source_type

if [ "$source_type" == "1" ]; then
    read -p "Enter path to .deb file: " deb_path
    
    # Strip surrounding quotes if present (handles copy-paste)
    deb_path=$(echo "$deb_path" | sed "s/^['\"]//; s/['\"]$//")
    
    # Expand ~ to home directory
    deb_path="${deb_path/#\~/$HOME}"
    
    # Get absolute path
    deb_path=$(realpath "$deb_path" 2>/dev/null || echo "$deb_path")
    
    if [ ! -f "$deb_path" ]; then
        echo -e "${RED}Error: File not found: $deb_path${NC}"
        exit 1
    fi
    
    SOURCE_TYPE="local"
    SOURCE_PATH="$deb_path"
    DEB_FILENAME=$(basename "$deb_path")
    
    echo ""
    echo "üîç Extracting package information..."
    CONTROL_INFO=$(extract_deb_info "$deb_path")
    
elif [ "$source_type" == "2" ]; then
    read -p "Enter URL to .deb file: " deb_url
    SOURCE_TYPE="url"
    SOURCE_PATH="$deb_url"
    DEB_FILENAME=$(basename "$deb_url")
    
    echo ""
    echo "‚ö†Ô∏è  Cannot extract info from remote .deb"
    CONTROL_INFO=""
else
    echo "Invalid option"
    exit 1
fi

echo ""
echo "üìù Package Information"

# Maintainer info
echo ""
read -p "üë§ Maintainer name [Your Name]: " maintainer_name
maintainer_name=${maintainer_name:-Your Name}
read -p "üìß Maintainer email [your.email@example.com]: " maintainer_email
maintainer_email=${maintainer_email:-your.email@example.com}

# Try to suggest package name from filename
SUGGESTED_NAME=$(echo "$DEB_FILENAME" | sed 's/_.*//; s/\.deb$//' | tr '[:upper:]' '[:lower:]')
read -p "Package name [$SUGGESTED_NAME]: " pkgname
pkgname=${pkgname:-$SUGGESTED_NAME}

# Try to extract version from .deb filename or control
SUGGESTED_VER=$(echo "$DEB_FILENAME" | sed 's/.*_\([0-9][0-9.]*\).*/\1/')
if [ -n "$CONTROL_INFO" ]; then
    CONTROL_VER=$(echo "$CONTROL_INFO" | grep "^Version:" | awk '{print $2}' | cut -d- -f1)
    [ -n "$CONTROL_VER" ] && SUGGESTED_VER="$CONTROL_VER"
fi
read -p "Version [$SUGGESTED_VER]: " pkgver
pkgver=${pkgver:-$SUGGESTED_VER}

read -p "Release [1]: " pkgrel
pkgrel=${pkgrel:-1}

read -p "Architecture [x86_64]: " arch
arch=${arch:-x86_64}

# Try to extract description
if [ -n "$CONTROL_INFO" ]; then
    CONTROL_DESC=$(echo "$CONTROL_INFO" | grep "^Description:" | cut -d: -f2- | xargs)
fi
read -p "Description [$CONTROL_DESC]: " pkgdesc
pkgdesc=${pkgdesc:-$CONTROL_DESC}

read -p "URL [https://example.com]: " url
url=${url:-https://example.com}

read -p "License [custom]: " license
license=${license:-custom}

echo ""
echo -e "${YELLOW}üîó Dependency Detection${NC}"
echo "1) Automatic (scan binaries for dependencies)"
echo "2) Manual (specify dependencies yourself)"
echo "3) Both (auto-detect + manual additions)"
read -p "Select option [1-3] (1): " dep_mode
dep_mode=${dep_mode:-1}

FINAL_DEPS=()

if [ "$dep_mode" == "1" ] || [ "$dep_mode" == "3" ]; then
    # Auto-detect dependencies
    if [ "$SOURCE_TYPE" == "local" ]; then
        AUTO_DEPS=$(deep_analyze_dependencies "$deb_path")
        
        if [ -n "$AUTO_DEPS" ]; then
            echo -e "${GREEN}‚úì Auto-detected dependencies: ${AUTO_DEPS}${NC}"
            IFS=',' read -ra AUTO_DEPS_ARRAY <<< "$AUTO_DEPS"
            FINAL_DEPS+=("${AUTO_DEPS_ARRAY[@]}")
        fi
    fi
    
    # Also check control file dependencies
    if [ -n "$CONTROL_INFO" ]; then
        CONTROL_DEPS=$(echo "$CONTROL_INFO" | grep "^Depends:" | cut -d: -f2- | sed 's/,/ /g; s/ *([^)]*)//g; s/  */ /g' | xargs)
        
        if [ -n "$CONTROL_DEPS" ]; then
            echo ""
            echo "üîÑ Translating control file dependencies..."
            
            for deb_dep in $CONTROL_DEPS; do
                arch_dep=$(translate_package "$deb_dep")
                
                if [ "$arch_dep" == "strip-dev" ]; then
                    continue
                fi
                
                if verify_arch_package "$arch_dep"; then
                    FINAL_DEPS+=("$arch_dep")
                    echo -e "  ${GREEN}‚úì${NC} $deb_dep ‚Üí $arch_dep"
                elif verify_arch_package "$deb_dep"; then
                    FINAL_DEPS+=("$deb_dep")
                    echo -e "  ${GREEN}‚úì${NC} $deb_dep (no translation needed)"
                else
                    echo -e "  ${YELLOW}‚ö†${NC} $deb_dep ‚Üí $arch_dep (not in repos, check AUR)"
                fi
            done
        fi
    fi
fi

if [ "$dep_mode" == "2" ] || [ "$dep_mode" == "3" ]; then
    echo ""
    if [ "$dep_mode" == "3" ] && [ ${#FINAL_DEPS[@]} -gt 0 ]; then
        CURRENT_DEPS=$(IFS=, ; echo "${FINAL_DEPS[*]}")
        read -p "Additional dependencies [$CURRENT_DEPS]: " manual_deps
        manual_deps=${manual_deps:-$CURRENT_DEPS}
    else
        read -p "Dependencies (comma-separated): " manual_deps
    fi
    
    if [ -n "$manual_deps" ]; then
        IFS=',' read -ra MANUAL_DEPS_ARRAY <<< "$manual_deps"
        FINAL_DEPS=("${MANUAL_DEPS_ARRAY[@]}")
    fi
fi

# Remove duplicates and create depends array
UNIQUE_DEPS=($(echo "${FINAL_DEPS[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))

if [ ${#UNIQUE_DEPS[@]} -gt 0 ]; then
    depends_array="depends=("
    for dep in "${UNIQUE_DEPS[@]}"; do
        dep=$(echo "$dep" | xargs)
        [ -n "$dep" ] && depends_array+="'$dep' "
    done
    depends_array+=")"
else
    depends_array="depends=()"
fi

echo ""
read -p "üìÅ Build directory [/tmp/deb2arch-build]: " build_dir
build_dir=${build_dir:-/tmp/deb2arch-build}

# Strip quotes from build directory
build_dir=$(echo "$build_dir" | sed "s/^['\"]//; s/['\"]$//")
build_dir="${build_dir/#\~/$HOME}"

# Create build directory first
mkdir -p "$build_dir"

read -p "üì¶ Save built package to [${build_dir}]: " pkg_save_dir
if [ -z "$pkg_save_dir" ] || [ "$pkg_save_dir" == "${build_dir}" ]; then
    pkg_save_dir="${build_dir}"
else
    pkg_save_dir=$(echo "$pkg_save_dir" | sed "s/^['\"]//; s/['\"]$//")
    pkg_save_dir="${pkg_save_dir/#\~/$HOME}"
fi

echo ""
read -p "üöÄ Install package after building? [y/N]: " install_pkg
install_pkg=${install_pkg:-n}

mkdir -p "$pkg_save_dir"

# Generate PKGBUILD
echo ""
echo "‚úçÔ∏è  Generating PKGBUILD..."

pkgbuild_save="${build_dir}/PKGBUILD"

cat > "$pkgbuild_save" << EOF
# Maintainer: $maintainer_name <$maintainer_email>
pkgname=$pkgname
pkgver=$pkgver
pkgrel=$pkgrel
pkgdesc="$pkgdesc"
arch=('$arch')
url="$url"
license=('$license')
$depends_array
EOF

if [ "$SOURCE_TYPE" == "local" ]; then
    cat >> "$pkgbuild_save" << PKGEOF
source=("file://$SOURCE_PATH")
sha256sums=('SKIP')

package() {
    cd "\${srcdir}"
    
    # Extract .deb
    ar x "$DEB_FILENAME"
    
    # Extract data
    if [ -f data.tar.xz ]; then
        bsdtar -xf data.tar.xz -C "\${pkgdir}"
    elif [ -f data.tar.gz ]; then
        bsdtar -xf data.tar.gz -C "\${pkgdir}"
    elif [ -f data.tar.zst ]; then
        bsdtar -xf data.tar.zst -C "\${pkgdir}"
    fi
    
    # Fix permissions comprehensively
    find "\${pkgdir}" -type d -exec chmod 755 {} +
    find "\${pkgdir}" -type f -exec chmod 644 {} +
    
    # Fix executables in common locations
    for dir in usr/bin usr/sbin bin sbin; do
        [ -d "\${pkgdir}/\${dir}" ] && find "\${pkgdir}/\${dir}" -type f -exec chmod 755 {} +
    done
    
    # Fix executables in /opt recursively
    if [ -d "\${pkgdir}/opt" ]; then
        find "\${pkgdir}/opt" -type f \( -executable -o -name "*.sh" -o -name "*.py" \) -exec chmod 755 {} +
        find "\${pkgdir}/opt" -type f -exec sh -c 'head -c 2 "\$1" 2>/dev/null | grep -q "^#!" && chmod 755 "\$1"' sh {} \;
    fi
    
    # Fix library permissions
    find "\${pkgdir}" -type f -name "*.so*" -exec chmod 755 {} + 2>/dev/null || true
}
PKGEOF
else
    cat >> "$pkgbuild_save" << PKGEOF
source=("$SOURCE_PATH")
sha256sums=('SKIP')

package() {
    cd "\${srcdir}"
    
    # Extract .deb
    ar x "$DEB_FILENAME"
    
    # Extract data
    if [ -f data.tar.xz ]; then
        bsdtar -xf data.tar.xz -C "\${pkgdir}"
    elif [ -f data.tar.gz ]; then
        bsdtar -xf data.tar.gz -C "\${pkgdir}"
    elif [ -f data.tar.zst ]; then
        bsdtar -xf data.tar.zst -C "\${pkgdir}"
    fi
    
    # Fix permissions comprehensively
    find "\${pkgdir}" -type d -exec chmod 755 {} +
    find "\${pkgdir}" -type f -exec chmod 644 {} +
    
    # Fix executables in common locations
    for dir in usr/bin usr/sbin bin sbin; do
        [ -d "\${pkgdir}/\${dir}" ] && find "\${pkgdir}/\${dir}" -type f -exec chmod 755 {} +
    done
    
    # Fix executables in /opt recursively
    if [ -d "\${pkgdir}/opt" ]; then
        find "\${pkgdir}/opt" -type f \( -executable -o -name "*.sh" -o -name "*.py" \) -exec chmod 755 {} +
        find "\${pkgdir}/opt" -type f -exec sh -c 'head -c 2 "\$1" 2>/dev/null | grep -q "^#!" && chmod 755 "\$1"' sh {} \;
    fi
    
    # Fix library permissions
    find "\${pkgdir}" -type f -name "*.so*" -exec chmod 755 {} + 2>/dev/null || true
}
PKGEOF
fi

echo -e "${GREEN}‚úÖ PKGBUILD created: $pkgbuild_save${NC}"

# Build package
echo ""
read -p "üî® Build package now? [Y/n]: " build_now
build_now=${build_now:-y}

if [[ "$build_now" =~ ^[Yy]$ ]]; then
    echo ""
    cd "$build_dir"
    
    # Run makepkg in background with spinner
    makepkg -sf --noconfirm > /tmp/deb2arch-build.log 2>&1 &
    MAKEPKG_PID=$!
    
    show_spinner $MAKEPKG_PID "üî® Building package... "
    
    wait $MAKEPKG_PID
    BUILD_STATUS=$?
    
    if [ $BUILD_STATUS -eq 0 ]; then
        echo -e "${GREEN}‚úÖ Package built successfully!${NC}"
        
        PKG_FILE=$(ls -t ${pkgname}-${pkgver}-${pkgrel}-*.pkg.tar.zst 2>/dev/null | head -1)
        
        if [ -n "$PKG_FILE" ] && [ "$pkg_save_dir" != "$build_dir" ]; then
            mv "$PKG_FILE" "$pkg_save_dir/"
            echo -e "${CYAN}üì¶ Package saved to: ${pkg_save_dir}/${PKG_FILE}${NC}"
            PKG_FILE="${pkg_save_dir}/${PKG_FILE}"
        else
            echo -e "${CYAN}üì¶ Package location: ${build_dir}/${PKG_FILE}${NC}"
        fi
        
        if [[ "$install_pkg" =~ ^[Yy]$ ]]; then
            echo ""
            echo -e "${CYAN}üöÄ Installing package...${NC}"
            sudo pacman -U "$PKG_FILE" --noconfirm
            echo -e "${GREEN}‚úÖ Package installed!${NC}"
        fi
    else
        echo -e "${RED}‚ùå Build failed!${NC}"
        echo ""
        echo -e "${YELLOW}üí° Check build log: /tmp/deb2arch-build.log${NC}"
        tail -n 20 /tmp/deb2arch-build.log
        exit 1
    fi
else
    echo "Build skipped. To build manually:"
    echo "  cd $build_dir"
    echo "  makepkg -sf"
fi

echo ""
echo -e "${GREEN}‚ú® Done!${NC}"
