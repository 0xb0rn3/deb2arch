#!/usr/bin/env python3
"""
deb2arch Enhancement Module
Inspired by alien's conversion capabilities
"""

import os
import sys
import re
import subprocess
import tempfile
import shutil
from pathlib import Path
from typing import Dict, List, Tuple, Optional
import json

class DebPackageAnalyzer:
    """Advanced .deb package analysis inspired by alien"""
    
    def __init__(self, deb_path: str):
        self.deb_path = deb_path
        self.temp_dir = tempfile.mkdtemp(prefix="deb2arch_")
        self.control_data = {}
        self.scripts = {}
        
    def __del__(self):
        """Cleanup temp directory"""
        if hasattr(self, 'temp_dir') and os.path.exists(self.temp_dir):
            shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def extract_control(self) -> Dict:
        """Extract and parse control file comprehensively"""
        try:
            # Extract control.tar.*
            subprocess.run(['ar', 'x', self.deb_path], cwd=self.temp_dir, 
                         capture_output=True, check=True)
            
            # Find and extract control archive
            control_archives = list(Path(self.temp_dir).glob('control.tar.*'))
            if not control_archives:
                return {}
            
            control_archive = control_archives[0]
            
            # Decompress based on extension
            if control_archive.suffix == '.gz':
                cmd = ['tar', 'xzf', str(control_archive)]
            elif control_archive.suffix == '.xz':
                cmd = ['tar', 'xJf', str(control_archive)]
            elif control_archive.suffix == '.zst':
                cmd = ['tar', '--zstd', '-xf', str(control_archive)]
            else:
                cmd = ['tar', 'xf', str(control_archive)]
            
            subprocess.run(cmd, cwd=self.temp_dir, capture_output=True, check=True)
            
            # Parse control file
            control_file = Path(self.temp_dir) / 'control'
            if control_file.exists():
                return self._parse_control_file(control_file)
            
        except Exception as e:
            print(f"Warning: Control extraction failed: {e}", file=sys.stderr)
        
        return {}
    
    def _parse_control_file(self, control_path: Path) -> Dict:
        """Parse Debian control file with multi-line support"""
        data = {}
        current_field = None
        current_value = []
        
        with open(control_path, 'r', encoding='utf-8', errors='ignore') as f:
            for line in f:
                line = line.rstrip('\n')
                
                # New field
                if line and not line.startswith(' '):
                    # Save previous field
                    if current_field:
                        data[current_field] = '\n'.join(current_value)
                    
                    # Parse new field
                    if ':' in line:
                        field, value = line.split(':', 1)
                        current_field = field.strip()
                        current_value = [value.strip()]
                
                # Continuation line
                elif line.startswith(' ') and current_field:
                    current_value.append(line.strip())
        
        # Save last field
        if current_field:
            data[current_field] = '\n'.join(current_value)
        
        return data
    
    def extract_maintainer_scripts(self) -> Dict[str, str]:
        """Extract postinst, prerm, postrm, preinst scripts"""
        scripts = {}
        script_names = ['postinst', 'prerm', 'postrm', 'preinst']
        
        for script in script_names:
            script_path = Path(self.temp_dir) / script
            if script_path.exists():
                with open(script_path, 'r', encoding='utf-8', errors='ignore') as f:
                    scripts[script] = f.read()
        
        return scripts
    
    def get_conffiles(self) -> List[str]:
        """Extract list of configuration files"""
        conffiles_path = Path(self.temp_dir) / 'conffiles'
        if conffiles_path.exists():
            with open(conffiles_path, 'r') as f:
                return [line.strip() for line in f if line.strip()]
        return []
    
    def analyze_file_structure(self) -> Dict:
        """Analyze data.tar.* structure without full extraction"""
        try:
            data_archives = list(Path(self.temp_dir).glob('data.tar.*'))
            if not data_archives:
                return {}
            
            data_archive = data_archives[0]
            
            # Get file listing
            if data_archive.suffix == '.gz':
                cmd = ['tar', 'tzf', str(data_archive)]
            elif data_archive.suffix == '.xz':
                cmd = ['tar', 'tJf', str(data_archive)]
            elif data_archive.suffix == '.zst':
                cmd = ['tar', '--zstd', '-tf', str(data_archive)]
            else:
                cmd = ['tar', 'tf', str(data_archive)]
            
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            files = [f.strip('./') for f in result.stdout.strip().split('\n')]
            
            return {
                'total_files': len(files),
                'directories': [f for f in files if f.endswith('/')],
                'binaries': [f for f in files if f.startswith(('usr/bin/', 'usr/sbin/', 'bin/', 'sbin/'))],
                'libraries': [f for f in files if '.so' in f],
                'configs': [f for f in files if f.startswith('etc/')],
            }
            
        except Exception as e:
            print(f"Warning: File structure analysis failed: {e}", file=sys.stderr)
        
        return {}


class ScriptConverter:
    """Convert Debian maintainer scripts to Arch-compatible format"""
    
    @staticmethod
    def convert_postinst(script: str) -> str:
        """Convert postinst to Arch post_install"""
        if not script:
            return ""
        
        # Replace Debian-specific commands
        conversions = {
            r'update-alternatives': '# update-alternatives (Arch equivalent: manual symlink)',
            r'dpkg-divert': '# dpkg-divert (not applicable on Arch)',
            r'update-rc\.d': 'systemctl enable',
            r'invoke-rc\.d\s+(\S+)\s+start': r'systemctl start \1',
            r'deb-systemd-helper': 'systemctl',
        }
        
        converted = script
        for pattern, replacement in conversions.items():
            converted = re.sub(pattern, replacement, converted)
        
        # Wrap in post_install function
        return f"""post_install() {{
{ScriptConverter._indent_script(converted)}
}}
"""
    
    @staticmethod
    def convert_prerm(script: str) -> str:
        """Convert prerm to Arch pre_remove"""
        if not script:
            return ""
        
        converted = script
        converted = re.sub(r'invoke-rc\.d\s+(\S+)\s+stop', r'systemctl stop \1', converted)
        
        return f"""pre_remove() {{
{ScriptConverter._indent_script(converted)}
}}
"""
    
    @staticmethod
    def convert_postrm(script: str) -> str:
        """Convert postrm to Arch post_remove"""
        if not script:
            return ""
        
        return f"""post_remove() {{
{ScriptConverter._indent_script(script)}
}}
"""
    
    @staticmethod
    def _indent_script(script: str) -> str:
        """Indent script content"""
        lines = script.split('\n')
        # Skip shebang
        if lines and lines[0].startswith('#!'):
            lines = lines[1:]
        
        return '\n'.join('    ' + line if line.strip() else '' for line in lines)


class DependencyTranslator:
    """Enhanced dependency translation"""
    
    # Comprehensive mapping
    DEB_TO_ARCH = {
        # Development tools
        'build-essential': 'base-devel',
        'gcc': 'gcc',
        'g++': 'gcc',
        'make': 'make',
        'cmake': 'cmake',
        
        # Libraries - SSL/Crypto
        'libssl-dev': 'openssl',
        'libssl3': 'openssl',
        'libssl1.1': 'openssl',
        'libcrypto++': 'crypto++',
        
        # Libraries - Compression
        'zlib1g': 'zlib',
        'zlib1g-dev': 'zlib',
        'libbz2-1.0': 'bzip2',
        'libbz2-dev': 'bzip2',
        'liblzma5': 'xz',
        'liblzma-dev': 'xz',
        'libzstd1': 'zstd',
        'libzstd-dev': 'zstd',
        
        # Libraries - XML/Text
        'libxml2': 'libxml2',
        'libxml2-dev': 'libxml2',
        'libxslt1.1': 'libxslt',
        'libxslt1-dev': 'libxslt',
        
        # Libraries - Database
        'libsqlite3-0': 'sqlite',
        'libsqlite3-dev': 'sqlite',
        'libpq5': 'postgresql-libs',
        'libpq-dev': 'postgresql-libs',
        'libmariadb3': 'mariadb-libs',
        'libmariadb-dev': 'mariadb-libs',
        
        # Libraries - Network
        'libcurl4': 'curl',
        'libcurl4-openssl-dev': 'curl',
        'libcurl4-gnutls-dev': 'curl',
        
        # Libraries - Graphics/UI
        'libgtk-3-0': 'gtk3',
        'libgtk-3-dev': 'gtk3',
        'libgtk-4-1': 'gtk4',
        'libgtk-4-dev': 'gtk4',
        'libqt5core5a': 'qt5-base',
        'libqt5gui5': 'qt5-base',
        'libqt5widgets5': 'qt5-base',
        'qtbase5-dev': 'qt5-base',
        'libqt6core6': 'qt6-base',
        
        # Libraries - X11/Wayland
        'libx11-6': 'libx11',
        'libx11-dev': 'libx11',
        'libxext6': 'libxext',
        'libxrender1': 'libxrender',
        'libxcb1': 'libxcb',
        'libxcb-cursor0': 'xcb-util-cursor',
        'libwayland-client0': 'wayland',
        'libwayland-server0': 'wayland',
        
        # System libraries
        'libc6': 'glibc',
        'libc6-dev': 'glibc',
        'libstdc++6': 'gcc-libs',
        'libgcc-s1': 'gcc-libs',
        
        # Python
        'python3': 'python',
        'python3-dev': 'python',
        'python3-pip': 'python-pip',
        
        # Perl
        'perl': 'perl',
        'perl-base': 'perl',
        
        # Common utilities
        'coreutils': 'coreutils',
        'findutils': 'findutils',
        'grep': 'grep',
        'sed': 'sed',
        'gawk': 'gawk',
    }
    
    @classmethod
    def translate(cls, deb_pkg: str) -> Optional[str]:
        """Translate Debian package to Arch equivalent"""
        # Remove version constraints
        pkg = re.sub(r'\s*\([^)]*\)', '', deb_pkg).strip()
        
        # Direct mapping
        if pkg in cls.DEB_TO_ARCH:
            return cls.DEB_TO_ARCH[pkg]
        
        # Pattern matching
        # Remove -dev suffix
        if pkg.endswith('-dev'):
            base = pkg[:-4]
            if base in cls.DEB_TO_ARCH:
                return cls.DEB_TO_ARCH[base]
            return base
        
        # Remove lib prefix and version numbers
        if pkg.startswith('lib') and re.search(r'\d+$', pkg):
            base = re.sub(r'\d+$', '', pkg)
            if base in cls.DEB_TO_ARCH:
                return cls.DEB_TO_ARCH[base]
            return base
        
        # Return as-is if no translation found
        return pkg
    
    @classmethod
    def translate_list(cls, deb_deps: List[str]) -> List[str]:
        """Translate list of dependencies"""
        arch_deps = []
        seen = set()
        
        for dep in deb_deps:
            # Handle alternatives (dep1 | dep2)
            if '|' in dep:
                alternatives = [d.strip() for d in dep.split('|')]
                # Take first alternative
                dep = alternatives[0]
            
            arch_dep = cls.translate(dep)
            if arch_dep and arch_dep not in seen:
                arch_deps.append(arch_dep)
                seen.add(arch_dep)
        
        return arch_deps


class PKGBUILDEnhancer:
    """Generate enhanced PKGBUILD with alien-inspired features"""
    
    def __init__(self, analyzer: DebPackageAnalyzer):
        self.analyzer = analyzer
        self.control = analyzer.control_data
        self.scripts = analyzer.scripts
    
    def generate_install_file(self, output_path: str) -> bool:
        """Generate .install file for pre/post install scripts"""
        install_content = []
        
        # Convert scripts
        if 'preinst' in self.scripts:
            converted = ScriptConverter.convert_postinst(self.scripts['preinst'])
            if converted:
                install_content.append("pre_install() {\n" + converted + "\n}\n")
        
        if 'postinst' in self.scripts:
            converted = ScriptConverter.convert_postinst(self.scripts['postinst'])
            if converted:
                install_content.append(converted)
        
        if 'prerm' in self.scripts:
            converted = ScriptConverter.convert_prerm(self.scripts['prerm'])
            if converted:
                install_content.append(converted)
        
        if 'postrm' in self.scripts:
            converted = ScriptConverter.convert_postrm(self.scripts['postrm'])
            if converted:
                install_content.append(converted)
        
        if install_content:
            with open(output_path, 'w') as f:
                f.write('\n'.join(install_content))
            return True
        
        return False
    
    def get_enhanced_pkgbuild_section(self) -> Dict[str, str]:
        """Get enhanced sections for PKGBUILD"""
        sections = {}
        
        # Enhanced description from control
        if 'Description' in self.control:
            desc = self.control['Description']
            # Take first line for pkgdesc
            sections['pkgdesc'] = desc.split('\n')[0][:80]
        
        # Extract homepage
        if 'Homepage' in self.control:
            sections['url'] = self.control['Homepage']
        
        # Enhanced dependencies
        if 'Depends' in self.control:
            deps_raw = self.control['Depends']
            deps_list = [d.strip() for d in deps_raw.replace('\n', '').split(',')]
            arch_deps = DependencyTranslator.translate_list(deps_list)
            sections['depends'] = arch_deps
        
        # Optional dependencies
        if 'Recommends' in self.control:
            recommends = [d.strip() for d in self.control['Recommends'].split(',')]
            arch_optdeps = DependencyTranslator.translate_list(recommends)
            sections['optdepends'] = arch_optdeps
        
        # Conflicts
        if 'Conflicts' in self.control:
            conflicts = [d.strip() for d in self.control['Conflicts'].split(',')]
            sections['conflicts'] = DependencyTranslator.translate_list(conflicts)
        
        # Provides
        if 'Provides' in self.control:
            provides = [d.strip() for d in self.control['Provides'].split(',')]
            sections['provides'] = DependencyTranslator.translate_list(provides)
        
        return sections


def main():
    """CLI interface"""
    if len(sys.argv) < 2:
        print("Usage: deb2arch_enhancer.py <command> <deb_file> [options]", file=sys.stderr)
        print("\nCommands:", file=sys.stderr)
        print("  analyze      - Deep analysis of .deb package", file=sys.stderr)
        print("  deps         - Extract and translate dependencies", file=sys.stderr)
        print("  scripts      - Extract maintainer scripts", file=sys.stderr)
        print("  enhance      - Generate enhanced PKGBUILD sections", file=sys.stderr)
        sys.exit(1)
    
    command = sys.argv[1]
    
    if command == 'analyze' and len(sys.argv) >= 3:
        deb_file = sys.argv[2]
        analyzer = DebPackageAnalyzer(deb_file)
        
        print("=== Control Data ===")
        control = analyzer.extract_control()
        print(json.dumps(control, indent=2))
        
        print("\n=== File Structure ===")
        structure = analyzer.analyze_file_structure()
        print(json.dumps(structure, indent=2))
        
        print("\n=== Maintainer Scripts ===")
        scripts = analyzer.extract_maintainer_scripts()
        for name, content in scripts.items():
            print(f"\n--- {name} ---")
            print(content[:200] + "..." if len(content) > 200 else content)
    
    elif command == 'deps' and len(sys.argv) >= 3:
        deb_file = sys.argv[2]
        analyzer = DebPackageAnalyzer(deb_file)
        control = analyzer.extract_control()
        
        if 'Depends' in control:
            deps_raw = control['Depends']
            deps_list = [d.strip() for d in deps_raw.replace('\n', '').split(',')]
            arch_deps = DependencyTranslator.translate_list(deps_list)
            
            print(','.join(arch_deps))
        else:
            print('')
    
    elif command == 'scripts' and len(sys.argv) >= 3:
        deb_file = sys.argv[2]
        analyzer = DebPackageAnalyzer(deb_file)
        scripts = analyzer.extract_maintainer_scripts()
        
        # Output as JSON for easy parsing
        print(json.dumps({name: content for name, content in scripts.items()}))
    
    elif command == 'enhance' and len(sys.argv) >= 3:
        deb_file = sys.argv[2]
        analyzer = DebPackageAnalyzer(deb_file)
        analyzer.extract_control()
        analyzer.scripts = analyzer.extract_maintainer_scripts()
        
        enhancer = PKGBUILDEnhancer(analyzer)
        sections = enhancer.get_enhanced_pkgbuild_section()
        
        # Output as JSON
        print(json.dumps(sections, indent=2))
    
    else:
        print(f"Unknown command: {command}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
